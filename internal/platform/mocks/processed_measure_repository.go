// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"

	process_measures "bitbucket.org/sercide/data-ingestion/internal/process_measures"
	mock "github.com/stretchr/testify/mock"
)

// ProcessedMeasureRepository is an autogenerated mock type for the ProcessedMeasureRepository type
type ProcessedMeasureRepository struct {
	mock.Mock
}

// GetDailyClosureByID provides a mock function with given fields: ctx, id
func (_m *ProcessedMeasureRepository) GetDailyClosureByID(ctx context.Context, id string) (process_measures.ProcessedDailyClosure, error) {
	ret := _m.Called(ctx, id)

	var r0 process_measures.ProcessedDailyClosure
	if rf, ok := ret.Get(0).(func(context.Context, string) process_measures.ProcessedDailyClosure); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(process_measures.ProcessedDailyClosure)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetLoadCurveByID provides a mock function with given fields: ctx, id
func (_m *ProcessedMeasureRepository) GetLoadCurveByID(ctx context.Context, id string) (process_measures.ProcessedLoadCurve, error) {
	ret := _m.Called(ctx, id)

	var r0 process_measures.ProcessedLoadCurve
	if rf, ok := ret.Get(0).(func(context.Context, string) process_measures.ProcessedLoadCurve); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(process_measures.ProcessedLoadCurve)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMonthlyClosureByCup provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) GetMonthlyClosureByCup(ctx context.Context, q process_measures.QueryClosedCupsMeasureOnDate) (process_measures.ProcessedMonthlyClosure, error) {
	ret := _m.Called(ctx, q)

	var r0 process_measures.ProcessedMonthlyClosure
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryClosedCupsMeasureOnDate) process_measures.ProcessedMonthlyClosure); ok {
		r0 = rf(ctx, q)
	} else {
		r0 = ret.Get(0).(process_measures.ProcessedMonthlyClosure)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryClosedCupsMeasureOnDate) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMonthlyClosureByID provides a mock function with given fields: ctx, id
func (_m *ProcessedMeasureRepository) GetMonthlyClosureByID(ctx context.Context, id string) (process_measures.ProcessedMonthlyClosure, error) {
	ret := _m.Called(ctx, id)

	var r0 process_measures.ProcessedMonthlyClosure
	if rf, ok := ret.Get(0).(func(context.Context, string) process_measures.ProcessedMonthlyClosure); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(process_measures.ProcessedMonthlyClosure)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMonthlyClosureMeasuresByCup provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) GetMonthlyClosureMeasuresByCup(ctx context.Context, q process_measures.QueryMonthlyClosedMeasures) ([]process_measures.ProcessedMonthlyClosure, error) {
	ret := _m.Called(ctx, q)

	var r0 []process_measures.ProcessedMonthlyClosure
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryMonthlyClosedMeasures) []process_measures.ProcessedMonthlyClosure); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]process_measures.ProcessedMonthlyClosure)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryMonthlyClosedMeasures) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetProcessedDailyClosureByCup provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) GetProcessedDailyClosureByCup(ctx context.Context, q process_measures.QueryClosedCupsMeasureOnDate) (process_measures.ProcessedDailyClosure, error) {
	ret := _m.Called(ctx, q)

	var r0 process_measures.ProcessedDailyClosure
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryClosedCupsMeasureOnDate) process_measures.ProcessedDailyClosure); ok {
		r0 = rf(ctx, q)
	} else {
		r0 = ret.Get(0).(process_measures.ProcessedDailyClosure)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryClosedCupsMeasureOnDate) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListHistoryLoadCurve provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) ListHistoryLoadCurve(ctx context.Context, q process_measures.QueryHistoryLoadCurve) ([]process_measures.ProcessedLoadCurve, error) {
	ret := _m.Called(ctx, q)

	var r0 []process_measures.ProcessedLoadCurve
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryHistoryLoadCurve) []process_measures.ProcessedLoadCurve); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]process_measures.ProcessedLoadCurve)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryHistoryLoadCurve) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessedDailyClosureByCups provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) ProcessedDailyClosureByCups(ctx context.Context, q process_measures.QueryHistoryDailyClosureByCups) ([]process_measures.ProcessedDailyClosure, error) {
	ret := _m.Called(ctx, q)

	var r0 []process_measures.ProcessedDailyClosure
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryHistoryDailyClosureByCups) []process_measures.ProcessedDailyClosure); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]process_measures.ProcessedDailyClosure)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryHistoryDailyClosureByCups) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProcessedLoadCurveByCups provides a mock function with given fields: ctx, q
func (_m *ProcessedMeasureRepository) ProcessedLoadCurveByCups(ctx context.Context, q process_measures.QueryProcessedLoadCurveByCups) ([]process_measures.ProcessedLoadCurve, error) {
	ret := _m.Called(ctx, q)

	var r0 []process_measures.ProcessedLoadCurve
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.QueryProcessedLoadCurveByCups) []process_measures.ProcessedLoadCurve); ok {
		r0 = rf(ctx, q)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]process_measures.ProcessedLoadCurve)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, process_measures.QueryProcessedLoadCurveByCups) error); ok {
		r1 = rf(ctx, q)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SaveAllProcessedLoadCurve provides a mock function with given fields: ctx, processed
func (_m *ProcessedMeasureRepository) SaveAllProcessedLoadCurve(ctx context.Context, processed []process_measures.ProcessedLoadCurve) error {
	ret := _m.Called(ctx, processed)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []process_measures.ProcessedLoadCurve) error); ok {
		r0 = rf(ctx, processed)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveDailyClosure provides a mock function with given fields: ctx, processed
func (_m *ProcessedMeasureRepository) SaveDailyClosure(ctx context.Context, processed process_measures.ProcessedDailyClosure) error {
	ret := _m.Called(ctx, processed)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.ProcessedDailyClosure) error); ok {
		r0 = rf(ctx, processed)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveMonthlyClosure provides a mock function with given fields: ctx, processed
func (_m *ProcessedMeasureRepository) SaveMonthlyClosure(ctx context.Context, processed process_measures.ProcessedMonthlyClosure) error {
	ret := _m.Called(ctx, processed)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.ProcessedMonthlyClosure) error); ok {
		r0 = rf(ctx, processed)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveProcessedDailyLoadCurve provides a mock function with given fields: ctx, processed
func (_m *ProcessedMeasureRepository) SaveProcessedDailyLoadCurve(ctx context.Context, processed process_measures.ProcessedDailyLoadCurve) error {
	ret := _m.Called(ctx, processed)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, process_measures.ProcessedDailyLoadCurve) error); ok {
		r0 = rf(ctx, processed)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewProcessedMeasureRepository interface {
	mock.TestingT
	Cleanup(func())
}

// NewProcessedMeasureRepository creates a new instance of ProcessedMeasureRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewProcessedMeasureRepository(t mockConstructorTestingTNewProcessedMeasureRepository) *ProcessedMeasureRepository {
	mock := &ProcessedMeasureRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
