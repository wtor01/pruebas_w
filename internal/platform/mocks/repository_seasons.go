// Code generated by mockery v2.12.2. DO NOT EDIT.

package mocks

import (
	context "context"

	seasons "bitbucket.org/sercide/data-ingestion/internal/master_tables/seasons"
	mock "github.com/stretchr/testify/mock"

	testing "testing"

	uuid "github.com/satori/go.uuid"
)

// RepositorySeasons is an autogenerated mock type for the RepositorySeasons type
type RepositorySeasons struct {
	mock.Mock
}

// DeleteDayType provides a mock function with given fields: ctx, dayTypeId
func (_m *RepositorySeasons) DeleteDayType(ctx context.Context, dayTypeId uuid.UUID) error {
	ret := _m.Called(ctx, dayTypeId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, dayTypeId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteSeason provides a mock function with given fields: ctx, seasonId
func (_m *RepositorySeasons) DeleteSeason(ctx context.Context, seasonId uuid.UUID) error {
	ret := _m.Called(ctx, seasonId)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = rf(ctx, seasonId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetAllDayTypes provides a mock function with given fields: ctx, seasonId, search
func (_m *RepositorySeasons) GetAllDayTypes(ctx context.Context, seasonId string, search seasons.Search) ([]seasons.DayTypes, int, error) {
	ret := _m.Called(ctx, seasonId, search)

	var r0 []seasons.DayTypes
	if rf, ok := ret.Get(0).(func(context.Context, string, seasons.Search) []seasons.DayTypes); ok {
		r0 = rf(ctx, seasonId, search)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]seasons.DayTypes)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(context.Context, string, seasons.Search) int); ok {
		r1 = rf(ctx, seasonId, search)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, string, seasons.Search) error); ok {
		r2 = rf(ctx, seasonId, search)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetAllSeasons provides a mock function with given fields: ctx, search
func (_m *RepositorySeasons) GetAllSeasons(ctx context.Context, search seasons.Search) ([]seasons.Seasons, int, error) {
	ret := _m.Called(ctx, search)

	var r0 []seasons.Seasons
	if rf, ok := ret.Get(0).(func(context.Context, seasons.Search) []seasons.Seasons); ok {
		r0 = rf(ctx, search)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]seasons.Seasons)
		}
	}

	var r1 int
	if rf, ok := ret.Get(1).(func(context.Context, seasons.Search) int); ok {
		r1 = rf(ctx, search)
	} else {
		r1 = ret.Get(1).(int)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context, seasons.Search) error); ok {
		r2 = rf(ctx, search)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetDayType provides a mock function with given fields: ctx, dayTypeId
func (_m *RepositorySeasons) GetDayType(ctx context.Context, dayTypeId string) (seasons.DayTypes, error) {
	ret := _m.Called(ctx, dayTypeId)

	var r0 seasons.DayTypes
	if rf, ok := ret.Get(0).(func(context.Context, string) seasons.DayTypes); ok {
		r0 = rf(ctx, dayTypeId)
	} else {
		r0 = ret.Get(0).(seasons.DayTypes)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, dayTypeId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetDayTypeByMonth provides a mock function with given fields: ctx, month, isFestive
func (_m *RepositorySeasons) GetDayTypeByMonth(ctx context.Context, month int, isFestive bool) (seasons.DayTypes, error) {
	ret := _m.Called(ctx, month, isFestive)

	var r0 seasons.DayTypes
	if rf, ok := ret.Get(0).(func(context.Context, int, bool) seasons.DayTypes); ok {
		r0 = rf(ctx, month, isFestive)
	} else {
		r0 = ret.Get(0).(seasons.DayTypes)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, int, bool) error); ok {
		r1 = rf(ctx, month, isFestive)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetSeason provides a mock function with given fields: ctx, seasonId
func (_m *RepositorySeasons) GetSeason(ctx context.Context, seasonId string) (seasons.Seasons, error) {
	ret := _m.Called(ctx, seasonId)

	var r0 seasons.Seasons
	if rf, ok := ret.Get(0).(func(context.Context, string) seasons.Seasons); ok {
		r0 = rf(ctx, seasonId)
	} else {
		r0 = ret.Get(0).(seasons.Seasons)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, seasonId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// InsertDayTypes provides a mock function with given fields: ctx, seasonId, dayT
func (_m *RepositorySeasons) InsertDayTypes(ctx context.Context, seasonId string, dayT seasons.DayTypes) error {
	ret := _m.Called(ctx, seasonId, dayT)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, seasons.DayTypes) error); ok {
		r0 = rf(ctx, seasonId, dayT)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// InsertSeason provides a mock function with given fields: ctx, season
func (_m *RepositorySeasons) InsertSeason(ctx context.Context, season seasons.Seasons) error {
	ret := _m.Called(ctx, season)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, seasons.Seasons) error); ok {
		r0 = rf(ctx, season)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifyDayTypes provides a mock function with given fields: ctx, dayTypeId, dayT
func (_m *RepositorySeasons) ModifyDayTypes(ctx context.Context, dayTypeId uuid.UUID, dayT seasons.DayTypes) error {
	ret := _m.Called(ctx, dayTypeId, dayT)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, seasons.DayTypes) error); ok {
		r0 = rf(ctx, dayTypeId, dayT)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ModifySeason provides a mock function with given fields: ctx, seasonId, season
func (_m *RepositorySeasons) ModifySeason(ctx context.Context, seasonId uuid.UUID, season seasons.Seasons) error {
	ret := _m.Called(ctx, seasonId, season)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, uuid.UUID, seasons.Seasons) error); ok {
		r0 = rf(ctx, seasonId, season)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewRepositorySeasons creates a new instance of RepositorySeasons. It also registers the testing.TB interface on the mock and a cleanup function to assert the mocks expectations.
func NewRepositorySeasons(t testing.TB) *RepositorySeasons {
	mock := &RepositorySeasons{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
